package auth

import (
	"crypto/rand"
	"crypto/sha256"
	"crypto/subtle"
	"encoding/hex"
)

// TODO: double-check whether this is locked down enough...
// yes yes yes, I should be using bcrypt or another special password hashing function
// However, bcrypt is 'slow' (as intended), and API keys have to be verified on every request which would add
// considerable latency. API keys are long, high entropy strings which we control ourselves, so a single pass of
// SHA-256 with a salt should be perfectly fine.

func hashToken(token string, salt []byte) []byte {
	tokenBytes := append([]byte(token), salt...)
	hash := sha256.Sum256(tokenBytes)
	return hash[:]
}

// HashTokenWithRandomSalt will generate an SHA-256 hash (single iteration) of the given string with a random 16-byte
// salt. The salt is appended to the resulting hash, so it is entirely self-contained. Use CompareTokenAndHash to
// compare a string against the resulting hash.
//
// NOTE: you should generally not use this function, and instead use bcrypt or some other special password hashing
// function. This hashing method is NOT good enough for standard passwords. It should only be used for values with high
// entropy, and where verification speed is important.
func HashTokenWithRandomSalt(token string) []byte {
	salt := make([]byte, 16)
	_, _ = rand.Read(salt)

	hash := append(hashToken(token, salt), salt...)

	// encode as hex, so it is somewhat human-readable
	encoded := make([]byte, hex.EncodedLen(len(hash)))
	_ = hex.Encode(encoded, hash)
	return encoded
}

// CompareTokenAndHash will compare the given token against the given salted SHA-256 hash. The hash is assumed to be
// generated by the HashTokenWithRandomSalt function.
//
// NOTE: you should generally not use this function, and instead use bcrypt or some other special password hashing
// function. This hashing method is NOT good enough for standard passwords. It should only be used for values with high
// entropy, and where verification speed is important.
func CompareTokenAndHash(token string, hash []byte) error {
	decoded := make([]byte, hex.DecodedLen(len(hash)))
	if _, err := hex.Decode(decoded, hash); err != nil {
		return err
	}

	// SHA256 is always 32 bytes (duh); if this is ever changed to a different algorithm this needs to be modified!
	hashWithoutSalt := decoded[:32]
	salt := decoded[32:]

	hashToCheck := hashToken(token, salt)

	if subtle.ConstantTimeCompare(hashWithoutSalt, hashToCheck) == 1 {
		return nil
	}

	return ErrHashDoesNotMatch
}
